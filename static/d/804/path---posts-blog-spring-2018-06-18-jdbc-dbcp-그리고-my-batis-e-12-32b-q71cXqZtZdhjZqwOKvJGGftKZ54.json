{"data":{"markdownRemark":{"frontmatter":{"title":"JDBC -> DBCP -> MyBatis"},"html":"<h2>개요</h2>\n<p>MyBatis를 이용하는 이유.. 쓰다보니 편리한건 알겠는데 왜 편리한건지 이유에 대한 정리가 안되었다.</p>\n<p>그냥 편하게 쓰면 되겠징 룰루</p>\n<p>이렇게 생각하다가 막상 이 질문을 받았을 때 대답을 할 수 없었다. 편리하다고만 할 수는 없지 않은가.. 그니까 이게 왜 편리하냐궁ㅋ </p>\n<p>확실히 하고 싶어서 여러 포스트들을 찾아보고 정리하려 한다.</p>\n<hr>\n<br/>\n<h2>JDBC</h2>\n<blockquote>\n<p>Java DataBase Connectivity의 약자로 자바에서 데이터베이스에 접속할 수 있도록 하는 자바 API이다.</p>\n</blockquote>\n<p>데이터베이스 연동관련 자바를 배울 때 처음으로 접하는 것.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Connection conn = null;\nPrepareStatement pstmt = null;\n\ntry{\n    Class.forName(&quot;com.mysql.jdbc.Driver&quot;); // MySQL JDBC 드라이버\n\n    Connection conn = DriverManager.getConnection(&lt;URL&gt;, &lt;USERNAME&gt;, &lt;PASSWORD&gt;);\n\n    String sql = &quot;insert into member1 values(?,?,?,?)&quot;;\n\n    pstmt = conn.prepareStatement(sql);\n\n    pstmt.setString(1,&quot;test&quot;);\n\n    pstmt.setString(2,&quot;passwd&quot;);\n\n    pstmt.setString(3,&quot;김철수&quot;);\n\n    pstmt.setTimestamp(4, new Timestamp(System.currentTimeMillis()));\n\n    pstmt.executeUpdate();\n} catch(Exception e) {\n    e.printStackTrace();\n} finally {\n    try {\n        if(pstmt != null) try{ pstmt.close(); }catch(SQLException sqle){}\n\n        if(conn != null) try{ conn.close(); }catch(SQLException sqle){}\n\n}</code></pre></div>\n<p>해당 JDBC코드의 문제점이라고 할 수 있는 것은</p>\n<h4>하나의 SQL문을 실행할 때마다 커넥션을 열고 닫고를 해야한다.</h4>\n<p>이게 무슨 말이냐..</p>\n<p>서버 통신으로 10개의 SQL을 실행해야한다고 가정하면</p>\n<p>JDBC코드의 경우 커넥션 열고 닫기를 10번을 반복해야한다.</p>\n<p>웹 서버에서 물리적으로 DB서버에 최초로 연결되어 Connection 객체를 생성하는 부분은 서버의 자원을 많이 소모한다고 한다.</p>\n<p>SQL문이 많이 오가는 WAS는 이러한 이유로 JDBC는 대부분 쓰이지 않는다고 한다.</p>\n<p>그래서 DB연결의 부담을 줄이기 위해 나온 방법이 DBCP를 이용한 것이다.</p>\n<h2>DBCP</h2>\n<p>Database Connection Pool.</p>\n<p>해당 구현체의 역할은 다음과 같다</p>\n<ol>\n<li>WAS 실행 시 Connection객체를 미리 만들고 Pool 공간에 저장해둔다.</li>\n<li>HTTP 요청시 Pool의 Connection객체를 가져다 쓰고 반환한다.</li>\n</ol>\n<p>미리 만들어진 Connection을 쓰고 반환만 하기 때문에 DB연결 및 해제의 과정이 없어 Connection객체를 생성하는 비용을 줄일 수 있게 된다.</p>\n<h2>MyBatis</h2>\n<p>자바에서의 퍼시스턴스 프레임워크 중 하나.</p>\n<p>DBCP을 이용한 프레임워크라 볼 수 있고,</p>\n<p>JDBC보다 생산성이 높고 유지보수 측면에서 장점이 있다.</p>\n<p>내가 느낀 장점에 대해 얘기하자면...</p>\n<h3>SQL명령어를 자바 코드에서 분리하여 XML파일에 따로 관리.</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// root-context.xml\n...\n&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;\n    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;\n    &lt;property name=&quot;configLocation&quot; value=&quot;&lt;MyBatis 설정파일 경로&gt;&quot; /&gt;\n    &lt;property name=&quot;mapperLocation&quot; value=&quot;&lt;MyBatis Mapper파일 경로&gt;&quot; /&gt;\n&lt;/bean&gt;\n\n// mapper.xml\n...\n&lt;select id=&quot;getTime&quot; resultType=&quot;string&quot;&gt;\n    SELECT SYSDATE FROM dual\n&lt;/select&gt;</code></pre></div>\n<ul>\n<li>SQL문이 자바코드와 뒤엉키는 것을 방지하는 것 같다.</li>\n<li>확실히 SQL문 보기가 편하다.</li>\n<li>분리되어 있기 때문에 관리하기가 좀 더 용이하였다.</li>\n</ul>\n<br/>\n<h3>ResultSet 결과를 객체로 자동 매핑시켜주어 복잡한 매핑코드를 넣지 않아도 되는 것.</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">...\n&lt;select id=&quot;list&quot; resultType=&quot;org.onezero.domain.BoardVO&quot; parameterType=&quot;map&quot;&gt;\n    SELECT * FROM board\n&lt;/select&gt;</code></pre></div>\n<ul>\n<li>resultType이나 parameterType들을 기본 자료형, Collection, 특정 Value Object등으로 명시할 시 해당 타입으로 자동 매핑을 시켜준다. (객체일시 get, set메소드 필요)</li>\n<li>이것만 생각해도 소스코드가 확 줄어드는 것을 느낌.</li>\n</ul>\n<br/>\n<h3>SQL를 동적으로 구성하는 것이 가능하여 중복되는 SQL를 최소화 할 수 있다.</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// mapper.xml\n&lt;select id=&quot;searchList&quot; resultType=&quot;org.onezero.domain.BoardVO&quot; parameterType=&quot;map&quot;&gt;\n    SELECT * FROM board\n     WHERE bno &amp;gt; 0\n       &lt;if test=&quot;title != null&quot;&gt;\n        AND title LIKE #{title}\n       &lt;/if&gt;\n&lt;/select&gt;</code></pre></div>\n<ul>\n<li>\n<p>SQL안에 if element를 넣음으로써 문자열 검색기능을 선택적으로 실행할 것이다.</p>\n</li>\n<li>\n<p>if, choose(when, otherwise), trim(where, set), foreach등의 element들이 있다.</p>\n</li>\n</ul>"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/posts/blog/spring/2018-06-18-JDBC,-DBCP,-그리고-MyBatis/","previous":{"node":{"id":"fb40917b-43ed-5efd-b4c8-0dcf90fb47bc","frontmatter":{"title":"데이터베이스 인덱스는 뭘까..?","category":"database","date":"2018-06-17"},"fields":{"slug":"/posts/blog/database/2018-06-22-데이터베이스-인덱스(Index)/"}}},"next":{"node":{"id":"8160b41e-aad8-509f-bfaf-902871107429","frontmatter":{"title":"JWT를 이용한 token 인증 구현해보기.","category":"node-express","date":"2018-06-17 07:49:00 +0300"},"fields":{"slug":"/posts/blog/node-express/2018-06-17-jwt를-이용한-token인증/"}}}}}