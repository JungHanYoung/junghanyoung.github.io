{"data":{"markdownRemark":{"frontmatter":{"title":""},"html":"<h1>jwt를 이용한 token인증</h1>\n<h2>개요</h2>\n<p>React를 공부하다보니 PWA(Progressive Web Application)을 만들기 위해서는 서버 사이드 렌더링이 아닌 REAST API를 호출하여 데이터를 렌더링하는 방식을 많이 사용하는 것 같다. 서버 사이드 렌더링도 있는데 너무 어려워 보임 ):</p>\n<p>웹 어플리케이션에서 빠질 수 없는 것이 인증처리..</p>\n<p>보통 인증처리는 Session을 사용할 수 있지만 이는 REST API가 지향하는 방식이 아니라고 한다. </p>\n<p>그래서 REST API는 Session인증 대신 Token인증 방식을 이용한다.</p>\n<p>express와 sequelize를 활용, jwt를 이용해 토큰을 응답받는 API를 만든다.</p>\n<hr>\n<h2>API 설계</h2>\n<ul>\n<li>(POST)    /api/user/login</li>\n<li>(GET)     /api/user/me</li>\n</ul>\n<h2>1. LOGIN - 인증토큰 요청</h2>\n<ul>\n<li>username과 password로 로그인.</li>\n<li>token을 리턴한다.</li>\n</ul>\n<p>Request</p>\n<pre><code>{\n    \"username\": \"test\",\n    \"password\": \"testpw\"\n}\n</code></pre>\n<p>Response</p>\n<pre><code>{\n    \"success\": true,\n    \"token\": \"&#x3C;토큰>\"\n}\n</code></pre>\n<h2>2. ME</h2>\n<ul>\n<li>로그인시 받은 token을 header의 x-access-token을 보냄.</li>\n<li>x-access-token이 없을 시 Error 리턴</li>\n<li>token을 해독하여 유저 정보 리턴</li>\n</ul>\n<p>Request</p>\n<ul>\n<li>N/A</li>\n</ul>\n<p>Response</p>\n<pre><code>{\n    success: true,\n    user: {\n        id: ....,\n        username: ...,\n        iat: ...,\n        exp: ...,\n    }\n}\n</code></pre>\n<hr>\n<h2>프로젝트 생성</h2>\n<h3>프로젝트 구조</h3>\n<pre><code>&#x3C;Project>\n- node_modules\n- .babelrc\n- package.json\n- server.js\n- models\n - index.js\n - user.js\n- routes\n - index.js\n - user.js\n</code></pre>\n<h3>모듈 설치</h3>\n<pre><code>yarn add express sequelize mysql2 bcryptjs jsonwebtoken\nyarn add -D babel-core babel-preset-env babel-cli\n</code></pre>\n<ul>\n<li>express - 웹 서버</li>\n<li>sequelize - 데이터베이스 ORM</li>\n<li>mysql2 - 데이터베이스 커넥터</li>\n<li>bcryptjs - SHA 암호화</li>\n<li>jsonwebtoken(JWT) - 토큰 암호화\n<br/><br/></li>\n<li>babel-core, babel-preset-env, babel-cli - ES6 컴파일</li>\n</ul>\n<hr>\n<h2>서버, 데이터 모델 및 라우터</h2>\n<h3>서버</h3>\n<pre><code>// server.js\nimport express from 'express';\n\nimport models from './models';\nimport apiRouter from './routes';\n\nconst app = express();\n\napp.use(express.json());\n\napp.use('/api', apiRouter);\n\nmodels.sequelize.sync().then(() => {\n    app.listen(3000, () => console.log('Server is listening on port', 3000));\n});\n</code></pre>\n<h3>데이터 모델</h3>\n<pre><code>// models/index.js\nimport Sequelize from 'sequelize';\nimport path from 'path';\n\nconst sequelize = new Sequelize('testdb1', 'root', '1234', {\n    dialect: 'mysql',\n    host: 'localhost'\n});\n\nconst models = {\n    User: sequelize.import(path.join(__dirname, '/user'))\n};\n\nmodels.sequelize = sequelize;\nmodels.Sequelize = Sequelize;\n\nexport default models;\n\n// models/user.js\nexport default (sequelize, DataTypes) => {\n    const User = sequelize.define('user', {\n        id: {\n            type: DataTypes.INTEGER,\n            primaryKey: true,\n            autoIncrement: true\n        },\n        username: {\n            type: DataTypes.STRING,\n            unique: true\n        },\n        password: {\n            type: DataTypes.STRING\n        }\n    });\n\n    return User;\n};\n</code></pre>\n<ul>\n<li>sequelize를 이용, mysql과 연동</li>\n<li>user 스키마를 만듬</li>\n</ul>\n<h3>라우터</h3>\n<pre><code>// routes/index.js\nimport express from 'express';\n\nimport userRouter from './user';\n\nconst router = express.Router();\n\nrouter.use('/user', userRouter);\n\nexport default router;\n</code></pre>\n<br/>\n<h2>User Router*</h2>\n<ol>\n<li>username와 password로 로그인 (POST - /api/user/login)</li>\n<li>로그인 정보가 유효하면 토큰 응답 O</li>\n<li>로그인 정보가 유효하지 않을 시 토큰 응답 X</li>\n<li>Client는 로그인시 받은 토큰을 HTTP통신시 헤더에 넣어 서버로부터 인증을 받는다. (GET - /api/user/me)</li>\n</ol>\n<h3>로그인</h3>\n<pre><code>// routes/user.js\nimport express from 'express';\nimport models from '../models';\nimport bcrypt from 'bcryptjs';\nimport jwt from 'jsonwebtoken';\n\nconst router = express.Router();\n\n// POST - /api/user/login\n// Body - username, password\n// Response - success여부, token?\nrouter.post('/login', (req, res) => {\n    const { username, password } = req.body;\n\n    // username에 해당하는 정보 찾기\n    models.User\n        .findOne({\n            where: {\n                username\n            }\n        })\n        .then((result) => {\n            // 정보 유무 체크\n            if (!result) {\n                return res.status(404).json({\n                    success: false\n                });\n            }\n            // 비밀번호 비교\n            const valid = bcrypt.compareSync(password, result.password);\n            // 로그인 정보 유효함.\n            if (valid) {\n                const user = result.dataValues;\n                delete user.password;\n                const token = jwt.sign(user, 'Secret Key');\n                res.json({\n                    success: true,\n                    token\n                });\n            // 비밀번호가 틀림\n            } else {\n                res.status(403).json({\n                    success: false\n                });\n            }\n        })\n        // 에러 감지\n        .catch((err) => {\n            console.error(err);\n            res.status(500).json({\n                success: false\n            });\n        });\n});\n</code></pre>\n<ul>\n<li>jwt.sign함수 - plain obejct로 문자열 토큰을 만든다.</li>\n</ul>\n<h3>자신의 프로필</h3>\n<pre><code>// GET - /api/user/me\n// Body - N/A\n// Response - 유저정보\nrouter.get('/me', (req, res) => {\n    const token = req.headers['x-access-token'];\n\n    const userInfo = jwt.verify(token, 'Secret Key');\n\n    res.json(userInfo);\n});\n\nexport default router;\n</code></pre>\n<ul>\n<li></li>\n<li>jwt.verify함수 - 암호화된 토큰을 검증, 토큰을 해독한 값을 리턴</li>\n</ul>\n<br/>\n<hr>\n<br/>\n<h2>결과</h2>\n<p>로그인시</p>\n<pre><code>&#x3C;Request>\nPOST - /api/user/login\nheaders - None\nbody -\n{\n    \"username\": \"test\",\n    \"password\": \"testpw\"\n}\n->\n&#x3C;Response>\n{\n    \"success\": true,\n    \"token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MSwidXNlcm5hbWUiOiJ0ZXN0IiwiY3JlYXRlZEF0IjoiMjAxOC0wNi0xN1QwNjoxOTo1NC4wMDBaIiwidXBkYXRlZEF0IjoiMjAxOC0wNi0xN1QwNjoxOTo1NC4wMDBaIiwiaWF0IjoxNTI5MjE5NjM5fQ.2ZkBkxat8wVSzo29MzisrQLt1MXoypfUDM81ecW6ACg\"\n}\n</code></pre>\n<p>로그인 후 자신의 프로필</p>\n<pre><code>&#x3C;Request>\nGET - /api/user/me\nheaders - \n{\n    x-access-token: \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MSwidXNlcm5hbWUiOiJ0ZXN0IiwiY3JlYXRlZEF0IjoiMjAxOC0wNi0xN1QwNjoxOTo1NC4wMDBaIiwidXBkYXRlZEF0IjoiMjAxOC0wNi0xN1QwNjoxOTo1NC4wMDBaIiwiaWF0IjoxNTI5MjE5NjM5fQ.2ZkBkxat8wVSzo29MzisrQLt1MXoypfUDM81ecW6ACg\"\n}\nbody - None\n->\n&#x3C;Response>\n{\n    \"id\": 1,\n    \"username\": \"test\",\n    \"createdAt\": \"2018-06-17T06:19:54.000Z\",\n    \"updatedAt\": \"2018-06-17T06:19:54.000Z\",\n    \"iat\": 1529219639\n}\n</code></pre>"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/posts/blog/node-express/2018-06-17-jwt를-이용한-token인증/","previous":{"node":{"id":"fb40917b-43ed-5efd-b4c8-0dcf90fb47bc","frontmatter":{"title":"데이터베이스 인덱스는 뭘까..?","category":"database","date":"2018-06-17"},"fields":{"slug":"/posts/blog/database/2018-06-22-데이터베이스-인덱스(Index)/"}}},"next":{"node":{"id":"dcd7f1a5-872d-50df-8417-bd894d2601df","frontmatter":{"title":"JDBC -> DBCP -> MyBatis","category":"spring","date":"2018-06-17 07:49:00 +0300"},"fields":{"slug":"/posts/blog/spring/2018-06-18-JDBC,-DBCP,-그리고-MyBatis/"}}}}}